---
title: Trabalho ECDB - Grupo 4
author: José Lemos (pg49838), Paulo Seixal (pg49846), Rúben Fernandes (pg49847)
date: 14/04/2023

output:
  html_document:
    theme: united #united, spacelab, journal
    highlight: breezedark #zenburn, kate, breezedark
    toc: true
    toc_float:
      collapsed: true
      smooth_scroll: true
    number_sections: true
    code_folding: show
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{css, echo=FALSE}
.scroll {
  max-height: 300px;
  overflow-y: auto;
}
```

```{=html}
<style>
body {text-align: justify}
div.fontdoc {font-family: georgia;}
    body .main-container {
        max-width: 1750px;
    }
</style>
```
<div class = "fontdoc">

<font size="4">

<a name="topo"></a>

# *Packages*

Instalação dos *packages*.

```{r packages, eval=FALSE, echo=TRUE}


```

Importação dos *packages*.

```{r import1, message=FALSE, warning=FALSE, results='hide'}
library(TCGAbiolinks)
library(maftools)
library(DESeq2)
library(ggplot2)
library(summarytools)
library(scales)
library(viridis)
library(clusterProfiler)
library(org.Hs.eg.db)
library(AnnotationDbi)
library(pheatmap)
library(haven)
library(textshaping)
library(ggrepel)
library(EnhancedVolcano)
library(ComplexHeatmap)
library(RColorBrewer)
library(circlize)
library(genefilter)

```

# Explicação dos dados, sua origem e relevância {.tabset}

No âmbito da Unidade Curricular Extração de Conhecimento de Dados Biológicos, inserida no 1º ano de Mestrado de Bioionformática, foi proposta a realização de um trabalho que consta a análise de um conjunto de dados usando o programa R e os packages do Bioconductor.

O objetivo deste trabalho é analisar as informações genéticas presentes no dataset e extrair conhecimentos relevantes, utilizando técnicas de visualização e análise estatística em R, onde se esperam encontrar padrões e correlações que possam ser explorados para um melhor entendimento da patologia em estudo.

Neste caso, será utilizado o repositório TCGA-HNSC. Este repositório está incluido no projeto *The Cancer Genome Atlas (TCGA) Research Network*, uma iniciativa que visa recolher, partilhar e analisar dados de *Next Generation Sequencing (NGS),* com o principal foco um maior desenvolvimento da compreensão dos mecanismos do cancro a nível molecular.

O repositório TCGA-HNSC contém informações sobre pacientes com cancro do tipo escamoso da cabeça e pescoço. Estas informações podem ser utilizadas para estudar a expressão de genes e correlacioná-la com informações clínicas relevantes. A inclusão de variáveis clínicas, como informações demográficas dos pacientes, histórico de tabagismo/alcoolismo e características relacionadas à progressão da doença, pode ajudar a identificar fatores de risco e prever resultados clínicos para pacientes com este tipo de cancro.

A importância deste conjunto de dados reside no facto de que a análise de expressão génica poder fornecer *insights* valiosos sobre os processos moleculares subjacentes ao desenvolvimento e progressão do cancro do tipo escamoso da cabeça e pescoço. Combinando essas informações com as características clínicas dos pacientes, é possível identificar fatores de risco, prever resultados clínicos, bem como identificar alvos de desenvolvimento para novas terapias.

Do repositório TCGA-HNSC foram retirados e analisados três datasets:

## Expressão génica {.unnumbered}

Neste dataset, "data_stranded_second.csv" temos os resultado obtidos através do método stranded para RNA-seq. As nossas colunas serão as amostras enquanto que as linhas serão os genes, está representado também o "gene expression count" de cada gene em cada amostra. Através do estudo desta dataset será possivél efetuar várias análises como, verificar expressão diferencial, para obtermos maior conhecimento sobre os padrões da expresão genética e as sua implicações nas funcionalidades dos genes.

## Mutações {.unnumbered}

O dataset "mutation_data.csv" providencia nos com data das mutações genéticas das amostras estudadas no repositório de informação do TCGA-HNSC. Este inclui tópicos como localização do cromossoma, informação sobre os alelos do tumor, classificação de variantes, entre outros dados de genética e genómica. Enquadra-se no objetivo do nosso trabalho pois temos a possibilidade de analizar os efeitos das mutações na expressão genética e o potencial impacto nas funções das proteinas. Permite também estudar a relação das mutações com o tipo de cancro HNSC e entender se tem efeito na regulação da expressão genética.

## Metadados {.unnumbered}

O dataset "biodata.csv" possui informação sobre as pessoas que serviram de amostra para este projeto, desde relatório da patologia, estado do tumor, e histórico de tratamento médico a número de cigarro por dia. A informação deste dataset permite aos investigadores perceber melhor o relacionamento entre as características do paciente e do tumor. Por exemplo informação sobre o tipo e estado do tumor pode ajudar a melhor perceber os diferentes niveis de expressão genética entre tecidos normais ou cancerosos.

##  {.unnumbered}

# *Extração dos dados e preparação de ficheiros* {.tabset}

A extração dos dados do repositório TCGA-HNSC foi realizada com recurso ao package TCGABiolinks. Este package permitiu construir uma query para download de dados de expressão génica e de mutações, filtrada por tópicos como *data.category, experimental.strategy*, etc., tal como demonstrado no código apresentado de seguida.

Foi necessária uma posterior preparação dos dados através da função GDCprepare que junta todas as informações relacionadas com as amostras (por exemplo, informação clínica). Os dados dos ensaios foram aramzenados nas variáveis:

-   **data_unstranded**: refere-se ao número de contagens registadas para cada gene em cada amostra

-   **data_fpkm_unstrand:** refere-se ao número de contagens para cada gene após a normalização FPKM

Importante referir que as informações dos metadados foram retiradas diretamente do objeto '**tcga-hnsc**', através da função *colData().*

Estes dados foram posteriormente armazenados em ficheiros .csv

## Expressão génica {.unnumbered}

```{r datasets, echo=TRUE, message=FALSE, warning=FALSE, eval=FALSE}
#project info
project_summary = getProjectSummary('TCGA-HNSC')



#build query
query_gene = GDCquery(project = 'TCGA-HNSC',
        data.category = 'Transcriptome Profiling',
        experimental.strategy = 'RNA-Seq',
        workflow.type = 'STAR - Counts',
        access = 'open')

query_results = getResults(query_gene)


#download data
GDCdownload(query_gene)


#prepare data
tcga_hnsc = GDCprepare(query_gene, summarizedExperiment = TRUE)
data_unstranded = assay(tcga_hnsc, 'unstranded')
data_fpkm_unstrand = assay(tcga_hnsc, 'fpkm_unstrand')


#create files
write.csv(data_unstranded, 'data_unstranded.csv')
write.csv(data_fpkm_unstrand, 'data_fpkm_unstrand.csv')


```

## Mutações {.unnumbered}

```{r mutações, eval=FALSE, warning=FALSE}
#build query mutation data
query_mutation = GDCquery(project = 'TCGA-HNSC',
                          data.category = 'Simple Nucleotide Variation',
                          access = 'open')

query_mutation_results = getResults(query_mutation)


#download data
GDCdownload(query_mutation)


#prepare mutation data
mutation_data = GDCprepare(query_mutation, summarizedExperiment = TRUE)

#create files
write_csv(mutation_data, 'mutation_data.csv')
```

## Metadados {.unnumbered}

```{r eval=FALSE}

#create metadata
bio_data = colData(tcga_hnsc)
bio_data = as.data.frame(bio_data)
write_csv(bio_data, 'bio_data.csv')
```

##  {.unnumbered}

# Importação dos dados

```{r import}
#dataset expressão genica
gene_data = as.matrix(read.csv('data_unstranded.csv', row.names = 1))
gene_data_fpkm = as.matrix(read.csv('data_fpkm_unstrand.csv', row.names = 1))

#dataset biological data
bio_data = read.csv('bio_data.csv', row.names = 1)

#dataset mutation
mutation_data = read.csv('mutation_data.csv')
```

De maneira a evitar o download sucessivo dos datasets, decidiu-se por armazenar os dados localmente em ficheiros .csv

A importação dos ficheiro é demonstrada no segmento de código acima representado.

# Pré-processamento

```{r preprocessing}
#tratamento valores omissos
sum(is.na(gene_data))
sum(is.na(gene_data_fpkm))
sum(is.na(bio_data$definition))


#garantir que o barcode das amostras é o mesmo nos dados de gene_data e no bio_data
all(colnames(gene_data) %in% rownames(bio_data)) #False
rownames(bio_data) <- gsub("-", "\\.", rownames(bio_data)) #alterar - por .
all(colnames(gene_data) %in% rownames(bio_data)) # True

#retirar amostras de metastases (queremos apenas comparar tecido normal com tecido tumoral primário no DESeq2)
bio_data = bio_data[bio_data$definition != 'Metastatic',]
gene_data = gene_data[,colnames(gene_data) %in% rownames(bio_data)]
gene_data_fpkm = gene_data_fpkm[,colnames(gene_data_fpkm) %in% rownames(bio_data)]
all(colnames(gene_data) %in% rownames(bio_data)) # True

#confirmar a ordem dos barcodes das amostras
all(colnames(gene_data) == rownames(bio_data))
```

O pré-processamento de dados é uma etapa fundamental para garantir resultados precisos e confiáveis. Num primeira fase optamos por verificar o número de NAs no dataset de expressão génica (gene_data e gene_data_fpkm) e nos valores do bio_data\$definition, sendo estes os fatores que serão utilizados mais à frente na análise de genes diferencialmente expressos. Estes fatores irião dividir as amostras entre 'Primary Solid Tumor' e 'Solid Tissue Normal'. Neste caso, não se registam NAs em ambos os casos

Queremos também garantir que os barcodes das amostras em ambos os datasets são os mesmos. Assim sendo, foi necessária a troca dos '-' por '.' no nome das linhas do dataset dos metadados.

Uma vez que, apenas duas amostras recolhidas pertencem a tecido metastático, achamos que este número não seria suficientemente relevante para inferir sobre a diferença de expressão génica entre este tecido e outros. Assim sendo, optamos por remover as amostras correspondentes em ambos os datasets

# Seleção e análise sumária de variáveis {.tabset}

Devido à elevada quantidade de variáveis que compões os datasets, optou-se por fazer uma seleção de algumas variáveis que consideramos ser de maior relevância para o caso em estudo.

Assim sendo, optamos por selecionar e análisar brevemente sete variáveis distintas: tipo de tecido, local do tumor, sexo do paciente, idade do paciente, tabaco, consumo de álcool e estadiamento do tumor.

```{r summarytools}
definition = bio_data$definition #tipo de tecido
stage = bio_data$ajcc_clinical_stage #estadiamento
tissue = bio_data$tissue_or_organ_of_origin #local do tumor
alcohol = bio_data$alcohol_history #consumo de alcool
smoke = bio_data$pack_years_smoked #tabagismo (packs_per_year)
smoke_disc = ifelse(is.na(smoke), "No", ifelse(smoke > 0, "Yes", "No"))
sum(is.na(smoke)) == sum(smoke_disc=='No') #tabagismo (discretização)
gender = bio_data$gender #sexo
age = bio_data$age_at_index #idade
```

## Tipo de tecido {.unnumbered}

Nesta variável do dataset bio_data temos informação sobre a presença ou ausência de tecido tumoral nas amostras, representado pelos valores "Primary solid Tumor" e "Solid Tissue Normal", respetivamente.

A sua utilidade para o nosso objetivo reflete na possibilidade de comparar a expressão genética nos tecidos normais e tumorais e identificar genes sub ou superregulados ajudando a perceber melhor as alterações das moléculas relacionadas com o desenvolvimento e progressão do cancro

```{r tecido}
print(dfSummary(definition), style = 'grid', dfSummary.silent  = TRUE, method = 'render')

#tipo de tecido
ggplot(as.data.frame(definition), aes(x = definition, fill = stage)) + 
  geom_bar() + 
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  ylab('Frequencias')
```

## Local do tumor {.unnumbered}

A variável tissue_or_organ_of_origin providencia-nos com informação sobre o tecido ou orgão em que o tumor se desenvolveu. Ao considerar esta varíavel poderemos obter melhor contexto em relação ás células e aos seus comportamentos característicos em cada orgão e analizar como isso afeta o a progressão do tumor.

```{r local}
print(dfSummary(tissue), style = 'grid', dfSummary.silent  = TRUE, method = 'render')

#Local do tumor
ggplot(as.data.frame(tissue), aes(x = tissue, fill = stage)) + 
  geom_bar() + 
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  ylab('Frequencias')
```

## Sexo {.unnumbered}

A variável gender deste dataset simplesmente nos informa sobre o sexo do paciente.#Ao comparar os padrões do desenvolvimento de cancro e mudanças na expressão genética entre homem e mulher, podemos ter um melhor entendimento na presença ou não da intervenção que os mecanismos específicos de cada sexo podem ter e o quão impactante será. age = bio_data\$age_at_index

```{r sexo}
print(dfSummary(gender), style = 'grid', dfSummary.silent  = TRUE, method = 'render')

#Sexo
ggplot(as.data.frame(gender), aes(x = gender, fill = gender)) + 
  geom_bar() +
  geom_text(aes(label = paste0(round((..count..)/sum(..count..) * 100), "%")), 
            stat = "count", vjust = -0.5, size = 5) + 
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  ylab('Frequencias')
```

## Idade {.unnumbered}

A variável age_at_index representa a idade em qual os pacientes foram diagnosticados com cancro. Com estes dados podemos associar os biomarcadores específicos e diferenças nos mecanismos de cada idade, ao motivo do desenvolvimento e da localização do cancro.

```{r idade}
print(dfSummary(age), style = 'grid', dfSummary.silent  = TRUE, method = 'render')

#idade
ggplot(as.data.frame(age), aes(x = age)) + 
  geom_histogram(bins = 20, fill = 'lightblue', color = 'black') + 
  labs(title = 'Idades', x = 'Idade', y = 'Frequencias')
```

## Tabaco {.unnumbered}

A variável pack_years_smoked representa o número de maços de tabaco consumidos em média por cada ano pelas amostras. Assim podemos tentar correlacionar a quantidade responsável de exposição ao tabaco com mudanças na expressão genética e desenvolvimento do cancro.

```{r tabaco}
print(dfSummary(smoke), style = 'grid', dfSummary.silent  = TRUE, method = 'render')

#tabaco
ggplot(as.data.frame(smoke_disc), aes(x = smoke_disc)) +
  geom_bar() +
  ylab('Frequencias')
```

## Álcool {.unnumbered}

A variável alcohol_history representa se as amostras tiveram contacto com álcool ou bebidas alcoólicas no passado. Com isto podemos ponderar nas relações que a utilização do álcool pode ter com a expressão genética em células tumorais.

```{r alcool}
print(dfSummary(alcohol), style = 'grid', dfSummary.silent  = TRUE, method = 'render')

#alcool
ggplot(as.data.frame(alcohol), aes(x = alcohol, fill = alcohol)) + 
  geom_bar() +
  geom_text(aes(label = paste0(round((..count..)/sum(..count..) * 100), "%")), 
            stat = "count", vjust = -0.5, size = 5) + 
  ylab('Frequencies')
```

## Estadiamento {.unnumbered}

A variável ajcc_clinical_stage representa a extensão da progressão do tumor na respetiva amostra com valores que são denominados de forma crescente como "Stage I", "Stage II", "Stage III", "Stage IVA", "Stage IVB". Com esta informação as amostras poderam ser agrupadas por grupos e analisadas no que toca aos padrões de expressão genética de cada grupo, comparando-os.

```{r estadiamento}
print(dfSummary(stage), style = 'grid', dfSummary.silent  = TRUE, method = 'render')

s = as.data.frame(stage)
stage_freq = table(s$stage)
df = data.frame(stage = stage(stage_freq), freq = as.numeric(stage_freq))

slices = df$freq
names = df$stage.Var1
pct = round(slices/sum(slices)*100)

new_labels = paste(names, ' - ', slices, '(', pct, '%',')', sep="")

pie(slices, labels = new_labels, main = "Estadiamento do tumor", col = rainbow(6))
```

##  {.unnumbered}

# Mutações

Através do package *maftools,* foi realizado um breve estudo de mutações. O seu estudo é importante porque fornece uma maneira eficaz de analisar e visualizar dados complexos de mutação, permitindo identificar padrões e relações importantes e encontrar possíveis novos alvos terapêuticos.

```{r mutacoes2, message=FALSE, warning=FALSE, out.width = '1750px'}
maftools_input = read.maf(mutation_data)

plotmafSummary(maf = maftools_input,
               addStat = 'median',
               dashboard = TRUE)

```

Numa breve análise dos gráficos acima podemos concluir que a esmagadora maioria das mutações rencontradas nas amostras analisadas são mutações missense. Este tipo de mutações são mutações pontuais no qual uma única alteração de um nucleótido resulta na codificação de um aminoácido diferente. Vemos também que

```{r mutacoes3, message=FALSE, warning=FALSE, out.width = '1750px'}

oncoplot(maf = maftools_input,
         top = 10,
         removeNonMutated = TRUE)
```

# Filtragem do dataset através de análise univariada

```{r analise univariada, message=FALSE, warning=FALSE}

#realizar t-test e verificar p-values e reirar os genes com maior evidência de expressão diferencial
tt = rowttests(gene_data_fpkm, as.factor(bio_data$definition))
rank = order(tt$p.value)
p10000 = rank[1:10000]
rows = which(tt$p.value %in% tt$p.value[p10000])
rownames(tt)[rows] #genes com menor p-value, logo com maior probabilidade de serem diferencialmente expressos

#filtrar dataset de contagens v«elos valores anteriores
gene_data = gene_data[rownames(gene_data) %in% rownames(tt)[rows],]
dim(gene_data) #passa a contar apenas com os 10000 genes de menor p-value
```

# Análise da expressão diferencial

```{r expressão diferencial, message=FALSE, warning=FALSE}
dds = DESeqDataSetFromMatrix(countData = gene_data,
                             colData = bio_data,
                             design = ~ definition)


#filter counts under 20
keep = rowSums(counts(dds)) >= 20
dds = dds[keep,]


#set reference level
bio_data$definition = relevel(as.factor(bio_data$definition), ref = 'Solid Tissue Normal')


#run DESeq
dds = DESeq(dds)


#Quality control - idealmente condições semelhantes no mesmo cluster
vsdata = vst(dds, blind = FALSE)
plotPCA(vsdata, intgroup = 'definition')

#dispersion plot
plotDispEsts(dds)

#get results from DESeq 
res = results(dds, alpha = 0.05)
summary(res)

#signifiatives - only padj under 0.05
sigs = na.omit(res)
sigs = sigs[sigs$padj < 0.05,]

#explore results
summary(sigs)

```

Embora não seja necessário pré-filtrar genes de baixa contagem antes de executar as funções DESeq2, existem duas razões que tornam esta filtragem útil: ao remover linhas em que há muito poucas leituras, reduzimos o tamanho da memória do objeto de dados e aumentamos a velocidade das funções dentro do DESeq2. Esta filtragem pode também melhorar visualizações, já que recursos sem informações para expressão diferencial não serão incluidos nos gráficos.

## Volcano plot

```{r volcano, out.width= '1700px'}
#volcano plot
res.df = as.data.frame(res)
rownames(res.df) = gsub("\\..*","",rownames(res.df))
res.df$symbol = mapIds(org.Hs.eg.db, keys = rownames(res.df), keytype = 'ENSEMBL', column = 'SYMBOL')
res.df #changed ensembl to symbol genes

EnhancedVolcano(res.df, x= 'log2FoldChange', y = 'padj', lab = res.df$symbol,
                pCutoff = 1e-4, FCcutoff = 1) #plot
```

## Heat map

```{r heatmap, out.width= '1750px'}
#heatmap
sigs.df = as.data.frame(sigs)
rownames(sigs.df) = gsub("\\..*","",rownames(sigs.df))
sigs.df$symbol = mapIds(org.Hs.eg.db, keys = rownames(sigs.df), keytype = 'ENSEMBL', column = 'SYMBOL')
sigs.df #changed ensembl to symbol genes

sigs.df_top = sigs.df[(sigs.df$baseMean > 50) & (abs(sigs.df$log2FoldChange) > 5), ] #filtering for top genes
sigs.df_top = sigs.df_top[order(sigs.df_top$log2FoldChange, decreasing = TRUE),] #order by fold change
sigs.df_top #up regulated first, down regulated last

rlog_out = vst(dds, blind = FALSE) #normalized count from dds
rownames(rlog_out) = gsub("\\..*","",rownames(rlog_out))
mat = assay(rlog_out)[rownames(sigs.df_top), rownames(bio_data)] #matrix sig genes x samples
colnames(mat) = NULL
base_mean = rowMeans(mat)
mat.scaled = t(apply(mat, 1, scale)) #center and scale each column, then transpose
colnames(mat.scaled) = colnames(mat)

num_keep = 25
rows_keep = c(seq(1:num_keep), seq((nrow(mat.scaled)-num_keep), nrow(mat.scaled)))

l2_val =as.matrix(sigs.df_top[rows_keep,]$log2FoldChange) 
colnames(l2_val) = 'logFC'

col_logFC = colorRamp2(c(min(l2_val),0, max(l2_val)), c("blue", "white", "red")) 



ha <- HeatmapAnnotation(summary = anno_summary(gp = gpar(fill = 2), 
                                               height = unit(2, "cm")))
h1 <- Heatmap(mat.scaled[rows_keep,], cluster_rows = F, 
              column_labels = colnames(mat.scaled), name="Z-score",
              cluster_columns = T)
h2 <- Heatmap(l2_val, row_labels = sigs.df_top$symbol[rows_keep], 
              cluster_rows = F, name="logFC", top_annotation = ha, col = col_logFC)

h<-h1+h2
h
```

# Análise de enriquecimento {.tabset}

```{r enriquecimento}
#sobre-expressos
genes_up = rownames(sigs.df)[sigs.df$log2FoldChange > 2]
genes_up = gsub("\\..*","",genes_up)

GO_results = enrichGO(gene = genes_up, OrgDb = 'org.Hs.eg.db', keyType = 'ENSEMBL', ont = 'BP')


#sub-expressos
genes_down = rownames(sigs.df)[sigs.df$log2FoldChange < -2]
genes_down = gsub("\\..*","",genes_down)

GO_results2 = enrichGO(gene = genes_down, OrgDb = 'org.Hs.eg.db', keyType = 'ENSEMBL', ont = 'BP')

#plotting
barplot(GO_results, showCategory = 10, title = 'Upregulated')
barplot(GO_results2, showCategory = 10, title = 'Downregulated')
```

## Sobre-expressos {.unnumbered}

```{r enriquecimento up}
barplot(GO_results, showCategory = 10, title = 'Upregulated')
goplot(GO_results)
```

## Sub-expressos {.unnumbered}

```{r enriquecimento down}
barplot(GO_results2, showCategory = 10, title = 'Downregulated')
goplot(GO_results2)
```

##  {.unnumbered}
